몽고디비 인덱스

인덱스를 메모리에 올려놓기 때문에 인덱스를 많이 만들면 frequency swap 발생, 성능 낮아짐, 데이터와 연계되는 인덱스 또한 업데이트 되기 때문에 write 성능 떨어지고 -> read 성능도 역시 떨어지게됨
Query planner가 엉뚱한 인덱스를 골라서 성능이 떨어지는 경우가 발생함

Query planner : 이전에 실행한 쿼리 플랜을 캐싱 해놓음, 캐싱된 쿼리 플랜이 없다면 가능한 모든 쿼리 플랜을 조회 후 첫 batch(101)를 가장 좋은 성능으로 가져오는 플랜을 캐싱함, 성능이 너무 안좋아지면 작업 반복

1. Hint 이용 - 더 효율적인 인덱스가 생겨도 사용하지 못함, 수동으로 인덱스를 변경 해줘야함
2.  엄한 인덱스 사용 - 데이터에 따라 또다른 엄한 케이스가 생길 수 있음, 인덱스 삭제로 인해 영향받는 쿼리가 생길 수 있음

불필요한 인덱스를 쳐내야함

방법
1. prefix가 동일한 인덱스는 복합인덱스만 남겨두고 단일인덱스는 제거,
   정렬 키는 복합 인덱스와 동일하게 순서가 구성해야함,
   또한 단일 필드 인덱스의 경우 소트 방향을 고려하지 않아도됨, 양방향을 지원함

복합 인덱스의 경우 소팅 방향이 중요함, 마찬가지로양방향을 지원하기 때문에 방향을 일관되게 해야함

몽고디비는 많은 소켓을 지원, 다큐먼트 트랜잭션의 지원이 필요 하지 않다면 여러 쓰레드로 한번에 처리도 괜찮음

-- 몽고디비 사용 의미? 장점?,엔진, 인덱스, 최적화, 트랜잭션